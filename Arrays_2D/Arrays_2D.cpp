#include <stdlib.h>
#include <iostream>
#include <time.h>
using namespace std;

// Двумерные массивы (ДМ) это массивы, у которых каждый элемент характеризуется двумя индексами, индексом по строке и по столбцу.

int main()
{
    system("chcp 1251");
    system("cls");

    /* Работа с элементами одномерного массива проходит по индексам. В цикле к каждому элементу обращаюсь индивидуально по имени, которое состоит из названия самого
    массива и индекса его элемента. A[i] это обращение к i-му элементу массива. */
    int A[3] = { 10,20,30 };

    for (int i = 0; i < 3; i++)
    {
        cout << "A[" << i << "]=" << A[i] << ";";
        cout << endl;
    }
    cout << endl;
    system("pause");
    /* Чтобы убедиться что массив лежит в памяти непрерывно, щелкну точку остановы до вывода массива на экран, запущу F5 отладчик. В отладчике я вижу адрес моего масси-
    ва в ОЗУ 0 * 000000503474f828 (адрес начала массива в памяти) и его содержимое 10, 20, 30. Тип массива int[3] - из трех элементов типа int.

    Чтобы посмотреть в оперативной памяти нахождение массива, нажму Debug -> Windows -> Memory и любое из предоставленных четырех вариантов (чтобы можно было смотреть
    сразу 4 места в памяти. Выберу Память 1 и увижу память в виде HEX. Чтобы увидеть там что-то понятное нужно найти мой массив и представить внешний вид ячеек памяти в
    понятном виде. Т.к. массив содержит int нужно 4-х байтное целое, нажму ПКМ в поле HEX и выберу 4-х байтное целое (там много всего: 32 - float, 64 - double, Юникод,
    ANSI..). Далее ПКМ -> знаковое представление (чтобы полож/отриц.числа были с +/-). Далее надо скопировать адрес моего массива, он указан внизу в Locals. В Values,
    ПКМ, копировать ЗНАЧЕНИЕ! Вставляю значение в строку адрес сверху. Удалю все кроме адреса, Enter. Мой массив лежит в самом начале страницы (+10, +20, +30) друг за
    другом, занимая по 4 байта. Память сама линейная, но студия представляет ее в виде таблицы. Хотя сами ячейки в блоках модуля ОЗУ табличные, процессор и любая прог-
    рамма работает с памятью по адресу! Адрес это порядковый номер ячейки от 0 и до самой максимальной, до которой хватает объема ОЗУ.

    Что такое ДМ, как он лежит в памяти, как работает?
    ДМ это массив массивов. Работаем с ним как с таблицей, у которой есть строчки и столбцы. Работа с ДМ осуществляется через вложенные циклы. Каждый элемент ДМ облада-
    ет двумя индексами, индексом по строке и индексом по столбцу (внутри строки). Он нам нужен чтобы хранить данные в виде таблиц. Создается ДМ также как и одномерный
    но только с двумя скобками. */
    int B[3][4] = {};    // 3 строчки, 4 столбца (пустой ДМ)
    /* ДМ-ы нужны чтобы быстрее добираться до элементов и удобнее с ними работать. Возьму одномерный массив [15]. Чтобы добраться до 13 элемента нужно выполнить 13 опе-
    раций (от каждого элемента в цикле i++ перебрать все предыдущие значения). Представлю этот массив двумерным (3 строки по 5 элементов):
    1  2  3  4  5
    6  7  8  9 10
    11 12 13 14 15      
    Чтобы добраться до 13-го элемента не нужно перебирать элементы по порядку, определю что элемент находится во 2-й строке, 2-м столбце (счет идет с 0), пропущу 0-ю
    строку, потом 1-ю и перейду ко 2-й строке, а в ней пропущу 2 элемента и попаду в нужный (всего 4 действия, а не 13). Чем больше массивы, тем ярче выигрыш. К тому же
    таблицы это самый красивый и наглядный вывод на экран, и даже консоль выводит данные в табличном виде, она заполняет строку за строкой, сна-
    чала 1-у строку, потом 2-ю и так до конца сверху вниз. Получается в табличном виде я вывожу элементы на экран, храню их, работаю с ними. Это удобно, т.к. индек-
    сы по строке и по столбцу будут совпадать с тем что я увижу на экране. Еще раз, ДМ нужен для ХРАНЕНИЯ данных, с которыми мы можем работать как с таблицей. */

    for (int i = 0; i < 3; i++)                                             // цикл прохода по строкам
    {
        for (int j = 0; j < 4; j++)                                         // цикл прохода по содержимому строки (прохода по столбцам)
        {
            B[i][j] = rand() % 100;                                         // обращение к элементу 2D массива по его индексу
            cout << "B[" << i << "][" << j << "]=" << B[i][j] << "\t";      // во вложенных циклах мы обращаемся к каждому элементу вручную
        }
        cout << endl;
    }
    system("pause");
    system("cls");
    /* Есть формула для настройки ГСЧ. Вспомним, rand()%100 даст числа 0...99, rand()%100+1 даст сдвиг в диапазон от 1 до 100. В карсарах у меня было rand()%6+1 (чтобы
    не выпадал 0). Т.о. к получившемуся сгенерированному числу я могу добавить, отнять что угодно. Выведем формулу:

    - если я отниму 100: rand()%100-100, -100 от обеих границ диапазона и получу [-100...-1]
    - если я отниму  99: rand()%100-99, то получу диапазон [-99...0]
                         rand()%200; даст диапазон [0...+199]
    - если я отниму  99: rand()%200-99, то получу диапазон [-99...+100]

    Создав rand()%199; получу [0...198]. А чтобы получить сдвиг в диапазон [-99...+99] нужно отнять 99 и получить rand()%199-99 с диапазоном [-99...+99].
    Приведем к формуле: rand()%(100+99)-99 [-99...+99], либо еще приведем rand()%(100-(-99))-99 [-99...+99]. Умножим уравнение на -1 и преобразуем формулу:

        rand()%(А-В)+В      [B...A-1];

    где А это конец интервала -1, а В это начало диапазона. Эта формула ГСЧ в диапазоне от В включительно и до А-1. Т.е. от -99 включительно и до 100-1.

    Пример 1: Если я хочу сгенерировать числа от 137 до 248, то формула будет выглядеть так:
    rand()%(249-137)+137    [137..248]

    Пример 2: Если я хочу сгенерировать числа от -27...-3,
    rand()%(-2+27)-27     [-27...-3]

    Как это пояснить? Если преобразовать назад в rand()%(100-(-99))-99 и раскрыть скобки, получим rand()%199-99. Можно формулу еще и запомнить так: Начиная с числа -99
    сгенерировать число в 199 значений, получим диапазон от -99 до 99 значений (диапазон в 199 значений, начиная от числа -99). */

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            B[i][j] = rand() % (100 - (-99)) - 99;
            cout << "B[" << i << "][" << j << "]=" << B[i][j] << "\t";
        }
        cout << endl;
    }
    system("pause");
    system("cls");

    /* Рассмотрим как инициализировать ДМ значениями сразу при создании, а именно перечислением значений его элементов. Т.к. мы работаем с ним как с таблицей, а в памя-
    ти нет никаких строк и столбцов, нужно понять как лежит ДМ в памяти. При заполнении в УИ (строковая/списочная инициализация) происходит автоматическое разделение по
    строкам: */
    int Mass1[2][3] = { 1,2,3,4,5,6 };

    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            cout << "Mass1[" << i << "][" << j << "]=" << Mass1[i][j] << "\t";
        }
        cout << endl;
    }
    /* Заметим, что 1-е 3 элемента поместились в строку с индексом 0, а 2-е 3 элемента в в строку с индексом 1, след, по этой логике мы можем создавать массивы и иници-
    ализировать их вручную с группировкой по строкам при помощи фигурных скобок.
    (!) все элементы в двумерном массиве лежат последовательно, друг за другом: сначала нулевая строчка, потом первая,... */
    int Mass2[2][3] = { {1,2,3},{4,5,6} };                          // с разделением по строкам (сначала указывается нулевая строка, потом первая)
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            cout << "Mass2[" << i << "][" << j << "]=" << Mass2[i][j] << "\t";
        }
        cout << endl;
    }
    system("pause");
    system("cls");

    /* Поставим точку остановы и зайдем в отладчик. Как мы видим ДМ в отладчике? Во вкладке Locals мы видим общий адрес, адрес первой строчки, адрес второй строки. Ви-
    дим его как int[2][3] (в Types). Открываем его, видим две строки, в каждой строке по 3 элемента. Каждая строка выглядит как собственный одномерный массив (адрес, 3
    элемента). След, ДМ состоит из нескольких одномерных массивов, которые в памяти лежат последовательно, а след, благодаря такому расположению можно работать с ДМ как
    с таблицей, в которой строчка за строчкой располагаются элементы.
    Зайдем в память и найдем массив 1 в памяти: ПКМ -> копировать значения -> вставляем в адрес и удаляем все кроме адреса (ставим 4-х байтное целое) -> вижу свой мас-
    сив в самом начале, сперва нулевая строчка, потом первая.
    (!) т.к. массивы 1 и 2 создавались рядом, они и в памяти лежат тоже рядом.
    (!) в студии последняя колонка в памяти показывает попытки студии трактовать содержимое памяти в виде текста, пытается перевести в символы, но тут символов нет, по-
    этому выводится такой мусор. */

    int Mass3[2][3] = { 1,2,3,4 };                      // последние два значения будут нулями и попадут в последние элементы последней строки {1,2,3,4,0,0}
    int Mass4[2][3] = { {1,2},{3,4} };                  // нули поместятся в последний столбец словно они бы были {{1,2,0},{3,4,0}}

    /* (!) если мы не группируем по строчкам, пропущенные значения попадут в последние места по счету в виде нулей, а когда мы группируем по строкам и в каждой/какой-то
    строке не допишем элемент, то тогда в эту сгруппированную строку поместятся нули. */

    int Mass5[2][3] = { 5 };

    /* Если какому-то одному элементу нужно дать одно значение, например '5', то эта запись выполнится вот так {5,0,0,0,0,0}. Только самая первая ячейка с индексом 0;0
    возьмет на себя первое и еинственное число, отсутствие остальных чисел заполнит оставшиеся ячейки массива нулями. Но, чтобы поставить '5' на свое порядковое место в
    массиве (1-я строка, 1-й столбец) нужно сгруппировать - применить следующую запись {{},{0,5}}. Она преобразится вот так: {{0,0,0},{0,5,0}}. */

    int Mass6[2][3] = { {},{0,5} };

    /* Этот способ позволяет вписать значение в нужную ячейку, но если ДМ большой, то этот способ непрактичен. Чтобы одному какому-то элементу задать нужное значение
    нужно обратиться к нему по адресу, по его индексам. Т.о. если нам нужен только 1 элемент или несколько, создим пустой массив и обратимся к нужному элементу по его
    индексам: */

    int Mass7[2][3] = {};
    Mass7[1][1] = 5;                                    // эта операция поместит пятерку только в этот элемент массива Mass7[1][1]
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            cout << "Mass7[" << i << "][" << j << "]=" << Mass7[i][j] << "\t";
        }
        cout << endl;
    }

    /* Как работают индексы? (как с ними работает система)
    Индексы означают сколько нужно пропустить элементов чтобы добраться до нужного элемента. Когда мы пишем [1][1] мы говорим что нужно пропустить 1 строку и 1 элемент
    и в следующей строке попадем в нужную ячейку. Т.е. у нас элементы массива лежат попорядку друг за другом (5-й элемент находится 5-м по порядку). Или же это так по-
    нимается: [1][1] - пропустить одну строку и еще один элемент и попасть в следующий. Поэтому нумерация с нуля чтобы эта логика сработала. Если у нас элемент с индек-
    сами [0][0], мы встанем в начало массива (0;0), в первый элемент таблицы и ничего не пропустим. Если у нас [0][3], значит по строкам ничего не пропустим, но отсчи-
    таем 3 элемента и в 4-й поместим нужное значение.
    Все элементы лежат последовательно, след, работа идет от начала массива и до нужного элемента. Компилятор сдвигается и попадает в нужное место, записывает там зна-
    чение. Т.о. сам сдвиг мы указываем компилятору с помощью индексов. Индексы вычисляются компилятором и он записывает данные в нужный элемент в вычисленное место:
    [1][1] = 1*3 + 1 = 4
    (нужно пропустить 1 строку из 3-х элементов в ней и еще пропустить один элемент в самой строке. Получаем 4 элемента, а в 5-м компилятор запишет результат)
    Вот так работает наша программа с памятью, но нам так работать не нужно. Нам же нужно вводить номер строки и столбца и попадать в нужное место. */
    system("pause");
    system("cls");

    // Найдем min и max элементы в массиве. Создадим цикл задания значений элементов массива и цикл работы.
    const int rows = 10;
    const int columns = 6;
    int Array[rows][columns]{};
    int max = 0, min = 0;
    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < columns; j++)
        {
            do                                                              // сделаем этот цикл для исключения определенных цисел из ГСЧ
            {
                Array[i][j] = rand() % (100 - (-99)) - 99;
                // ниже условие перегенерации при выпадании от -9 до +9 включительно
            } while (Array[i][j] > -10 && Array[i][j] < 10);
            cout << "A[" << i << "][" << j << "]=";
            if (Array[i][j] > 0)cout << " ";                                // добавим пробел перед положительным числом
            cout << Array[i][j] << "\t";
        }
        cout << endl;
    }
    system("pause");
    system("cls");
    /* (!) число 35 занимает 2 знака, а число -35 занимает 3 знака. Дадим пробел вместо плюса чтобы было тоже 3 знака.

    Как мы можем работать с массивом? Т.к. двумерный массив это таблица во всех операциях, мы можем работать с его элементами строчка за строчкой, от нулевой строки до
    последней. Рассмотрим пример. Попробуем найти в каждой строчке максимальный элемент. Чтобы его найти нужно перед тем как приступать к строчке задать значение пере-
    менной max, в данной случае проще принять какой-то из наших элементов за максимум. В каждой строчке мы представим нулевой j элемент за максимум, а потом с ним
    сравним все оставшиеся элементы в строчке. Если находим значение больше чем значение этого элемента, то найденный элемент будет считаться максимальным. Перед тем
    как зайти внутрь каждой строки мы пропишем максимум (для каждой 'i-й' строки нулевой элемент будет считаться максимальным). */

    for (int i = 0; i < rows; i++)
    {
        max = Array[i][0];                                                                  // к счетчику j мы не можем тут обратиться, он живет только в цикле ниже
        for (int j = 0; j < columns; j++)
        {
            if (Array[i][j] > max)max = Array[i][j];
        }
        cout << "Максимальный элемент " << i << "-й строки равен " << max << endl;          // мы находим не индексы максимального элемента, а его значение
    }
    cout << endl;
    /* Помимо того, что мы можем работать с массивом построчно, мы также можем работать с массивом и по столбцам. Я могу взять все элементы 1-го столбца и обработать,
    потом 2-го, потом 3-го и т.д. Когда мы работали с массивом построчно, мы брали строку, начиная с нулевого и все последующие элементы строки обрабатывали. И так с
    каждой строкой. А теперь нужно также со столбцами. Взять первый элемент столбца и обработать последующие элементы сверху вниз. Чтобы так получилось нужно циклы по-
    менять местами. Если в первом случае у нас внешний был цикл прохода по строкам, а внутренний - проход по элементам самой строки. Сейчас же вншний цикл должен быть
    циклом прохода по столбцам, а внутренний по строкам, помня, что строки меняются от 0 до rows, а столбцы от 0 до columns.
    Теперь в каждом столбце ищем минимальный элемент и точно также принимаем изначально за минимальный элемент - первый элемент в столбце. Первый элемент в столбце бу-
    дет иметь всегда индекс по строке 0, а по столбцу индекс будет меняться (0,1,2...). */

    for (int j = 0; j < columns; j++)                       // цикл прохода по столбцам
    {
        min = Array[0][j];                                  // для каждого j-го столбца в начале считаем минимальный элемент с индексом 0 по строке (первый в столбце)
        for (int i = 0; i < rows; i++)                      // цикл прохода по элементам внутри столбца (по строкам)
        {
            if (Array[i][j] < min)min = Array[i][j];
        }
        cout << "Минимальный элемент " << j << "-го столбца равен " << min << endl;
    }
    /* (!) поменяв местами внешний и внутренний циклы, мы можем работать по столбцам, а не по строкам. Но главное помнить, что количество строк регламентировано пере-
    менной rows, а количество столбцов переменной columns и в квадратных скобках Array[0][j] сперва идут строки, а потом столбцы. Индексы элементов менять нельзя. Всег-
    да первым указывается индекс по строке, а вторым индекс по столбцу. А перебирать элементы мы можем как угодно: вдоль или поперек (по строчкам или по столбцам). */
}