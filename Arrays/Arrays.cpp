#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;

/* Группировка данных - МАССИВЫ (хранилище, cловно переменная, но не для одной переменной, а для такого количества, которое нам нужно). Когда есть необходимость объеди-
нять данные в единое целое, мы можем объединить ОДНОТИПНЫЕ данные под общим именем при помощи массива. Массив - это набор однотипных данных, объединенных под одним еди-
ным именем. Массивы используются для обработки большого количества однотипных данных. Массив это когда мы под одним именем собираем данные одного типа. Эти данные нахо-
дятся в памяти друг за другом неразрывно, как вагоны поезда. Например, у нас есть массив - три объединенных элемента типа int, их значения 3,1,4. Имя такого масива бу-
дет train. Каждый элемент массива, каждая переменная, каждое значение, которое в нем хранится называется элемент массива и обладает одной характеристикой - индексом (по-
рядковым номером в массиве). Нумерация элементов в массиве начинается с нуля. Каждый элемент массива имеет свой уникальный индекс (индексы не повторяются). Т.о. в мас-
сивах есть правило: КОЛИЧЕСТВО ЭЛЕМЕНТОВ В МАССИВЕ РАВНО ИХ КОЛИЧЕСТВУ МИНУС ОДИН.

Например: train состоит из трех int, а они в свою очередь могут вести себя как отдельные переменные и мы можем с ними взаимодействовать как с отдельными переменными, но
тем не менее они вместе и объединены единым именем и мы с этим именем тоже можем работать как с единым целым. Т.е. массив можно представлять как единое целое, состоящее
из "n" элементов (в нашем случае из 3-х), а можем рассматривать как набор равнозначных равноценных элементов, каждый из которых обладает своим собственным индексом. В
нашем случае размер массива 3, индексы 0,1,2. Имя train, тип данных int (каждый элемент должен быть одного типа данных, например int).

                                                                              Как создается массив?
                                 Пишется тип данных, название массива, в квадратных скобках ставится индекс (количество элементов), а потом ';'
                                                                                  int Array[5];

Переменные в массиве можно не инициализировать. Конечно это некорректно, но ошибки не будет. Без инициализации там везде будет мусор, оставшийся там от предыдущего вла-
дельца этой памяти. Чтобы работать с элементами массива (помещать в них значения, вывести их на экран, выполнить вычисления и прочее), надо с каждым элементом массива
работать индивидуально по его индексу. Чтобы обратиться к какому-то элементу массива персонально, нужно указать имя массива и в квадратных скобках его индекс (применить
операцию индексирования). Выведем все 5 элементов массива на экран. Там везде мусор. Поместим туда значения, запишем Array[0] = -17; Правда по одному инициализировать
переменные не очень удобно.

Если вывести на экран элемент массива, которого нет, например 15, то это сработает и выведется не мусор, а какое-то число. Т.к. с массивами работа ведется по их место-
положению в памяти, место под 15 элемент будет высчитано в памяти. А число возникнет по следующей логике: раз элементы лежат друг с другом неразрывно, 5 элементов типа
int займут в памяти 20 байт. А когда мы скажем 15-й элемент, след, нужно отмотать 14 раз по 4 байта = 56 байт и потом там где-то в памяти найти 15-ю позицию. Та же кар-
тина будет если мы напишем Array[-1]. Тоже будет высчитано число для этого места. Но для компилятора это не будет ошибка, он место высчитает, а для нас это будет ошибка
(выход за границы массива).

(!) более грубая ошибка случится когда мы попытаемся записать что-нибудь в то место, которое нам не приналежит (Array[15]=1000;) Значение вложится, и студия не посчита-
ет это ошибкой т.к. с массивами работа ведется по их местоположению в памяти. Мы вложили 1000 в ту ячейку памяти, которая не принадлежит нашей программе. Когда мы вво-
дим int Array[5]; мы просим у ОС выделить 20 байт под хранение 5-ти элементов типа int, ОС выделяет. А мы получив 5 ячеек, пытаемся влезть в 15-ю и даже перезаписать ее
(ячейку, которая нам вообще не принадлежит). Одно дело если эта память принадлежит нашей программе, а если другой или же даже принадлежит самой ОС (ОЗУ одна на всех).
Одно дело если мы просто выведем на экран (заглянем туда), а если перезапишем! Так делать нельзя! НА СКОЛЬКО ЭЛЕМЕНТОВ ЗАПРАШИВАЕМ ПАМЯТИ, СО СТОЛЬКИМ КОЛИЧЕСТВОМ ЭЛЕ-
МЕНТОВ И РАБОТАЕМ, С ИНДЕКСАМИ ОТ НУЛЯ и до последнего элемента со значением N-1! */

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));

    // Создание массива из 5 целых чисел.
    int Array[5];                                                               // int (Array0, Array1, Array2, Array3, Array4)
    Array[0] = -17;                                                             // доступ к элементам массива по его индексу
    Array[1] = 3;
    Array[2] = -555;
    Array[3] = 12;
    Array[4] = 777;

    cout << Array[0] << endl;                                                   // вывод на экран (в консоль) нулевого элемента массива с индексом 0
    cout << Array[1] << endl;
    cout << Array[2] << endl;
    cout << Array[3] << endl;
    cout << Array[4] << endl;

    // cout << Array[15] << endl;                                               // выход за границы массива
    // cout << Array[-1] << endl;                                               // выход за границы массива
    system("pause");
    system("cls");

    /* Размеры массива сейчас задаются целочисленным литералом N в константе. Нельзя размер массива задать дробным числом (не может быть 3.5 элемента массива, словно 3.5
    человека), а также нельзя задавать переменными, т.к. переменная может измениться во время работы программы, а этого нельзя допускать. Например если мы создадим массив
    на 5 элементов, а потом изменим переменную на 50, словно в массиве 50 элементов, мы попадем в чужую ячейку памяти.

    Создадим новый массив с int с названием А (массив также работает и с другими типами данных). Неудобно заполнять массив, перечисляя все элементы. Поможет тут УИ (списко-
    вая/строковая инициализация). В ее фиг.скобках можно перечислить все значения элементов массива попорядку. Делать так ПОСЛЕ создания массива нельзя, только при создании
    массива. Теперь массив заполнен, выведу его на экран.
    Если я введу в свой массив из 4 элементов еще число 100 { -10,15,8,3,100 }, это будет ошибкой, программа не выполнится, однако если у меня массив из 4 элементов и я ту-
    да инициализирую лишь 3, то последний инициализируется нулем. Это абсолютно легитимно, след, можно инициализировать пустой массив, заполненный нулями.
    Правило: МЕНЬШЕ МОЖНО, БОЛЬШЕ НЕТ! */

    const int size = 4;                                                         // константа для задания размера массива
    int A[size] = { -10,15,8 };                                                 // инициализация массива с помощью УИ

    cout << A[0] << endl;
    cout << A[1] << endl;
    cout << A[2] << endl;
    cout << A[3] << endl;

    // Объявление и инициализация пустого массива, заполненного нулями.
    float B[size] = {};                                                         // с массивами знак '=' перед УИ можно не ставить float B[size]{};

    cout << "Массив В: " << endl;                                               // УИ помещает корректные значения. Если float, то литерал будет типа float и т.д.
    cout << B[0] << endl;
    cout << B[1] << endl;
    cout << B[2] << endl;
    cout << B[3] << endl;

    // Можно записать массив и горизонтально:
    double X[size] = { 0.3,4.4,3.5,5.6 };
    cout << "Массив X: " << endl;
    cout << X[0] << " " << X[1] << " " << X[2] << " " << X[3] << " " << endl;

    system("pause");
    /* Но неудобно их так один за другим выводить на экран, к каждому элементу нужно обращаться персонально. Т.к. выводы элементов массива на экран носят одинаковые
    действия, их можно поместить в цикл, особенно зная количество элементов в массиве. Добавим его в параметры цикла.

                                                                   Работа с элементами массива в цикле:
    (!) теперь ясно почему счетчик в цикле лучше начинать с нуля и меньше заданного числа, идеально попадаю в описание элементов массива. А отсюда и вывод на экран по-
    лучается без всяких доп.действий, просто вывод счетчика на экран! А после цикла необходимо поставить перевод строки. Каждый шаг цикла ассимилирую с индексом моего
    массива и тем самым сперва вывожу значение Array[0], потом Array[1], Array[2], Array[3] и Array[4].
    (!) несмотря на то, что работаю я в цикле, обращаюсь к каждому элементу массива персонально, по индексу (i), делая это в цикле, а не отдельно как раньше. В массиве
    с каждым элементом необходимо работать персонально, но, если операции одни и теже, можно делать это в цикле. */

    for (int i = 0; i < 5; i++)
    {
        cout << Array[i] << endl;                                               // либо можно через пробелы в одну строку
    }
    cout << endl;

    system("pause");
    system("cls");

    /* Можно массивы друг с другом складывать, перемножать, но ПОЭЛЕМЕНТНО! Один элемент одного массива с другим элементом другого массива и т.д. Целиком массив на мас-
    сив мы умножить/поделить... не можем!

    Циклы работы с массивами делятся на 3 этапа/цикла. Если нам позволяет задача и логика работы программы, мы можем все это соединить в один цикл, но не всегда так по-
    лучается. Рассмотрим на примере массива В этапы работы с массивом.


                                                                I. Цикл заполнения элементов массива */
    for (int i = 0; i < size; i++)
    {
        cout << "Введите значение " << i + 1 << "-го элемента массива: "; cin >> B[i];
    }
    /* Т.к. у массива 'В' размер задан константой size, мы вводим все элементы массива 'В' вручную поочереди. Как только массив заполнен, необходимо выполнить какие-то
    действия в цикле ниже:

                                                          II. Цикл выполнения действий над элементами массива
    Если условия моих циклов были бы абсолютно одинаковые, действия над элементами можно было бы выполнить в цикле заполнения. Сделаем операцию, первые два элемента
    массива умножим на 2 (так можно делать в цикле). Для этого элементы с индексами от 0 до 2 умножаем на 2. Технически это будет так, i < size/2 (size/2=2, i<2 даст
    элементы 0 и 1). */

    for (int i = 0; i < size / 2; i++)                                          // элементы с индексами от 0 до 2 (size/2)
    {
        B[i] *= 2;                                                              // первую половину массива домножим на 2
    }
    /* Мы видим, что обрабатывается в цикле не весь массив. И условия 1-го и 2-го цикла отличаются. Когда условия отличаются нельзя скомбинировать циклы (или нам придет-
    ся писать условие внутри цикла). В реальности мы все будем делать в одном цикле, и заполнять, и выполнять действия.

                                                          III. Цикл вывода на экран элементов массива.
    Выведу на экран все элементы массива, не только те, которые перемножил, а вообще все. В 1-м цикле у меня одно условие, во 2-м другое, в третьем 3-и параметры. Напи-
    шу в цикле перевод строки. */

    for (int i = 0; i < size; i++)
    {
        cout << "B[" << i << "]=" << B[i] << "; " << endl;
    }
    system("pause");
    system("cls");

    /* Все красиво вывелось в одну строчку, где первые два элемента с индексами 0 и 1, были умножены на 2, а последние два элемента остались без изменений. Т.о. можно
    работать с массивами через циклы. В большинстве случаев все пишется в одном цикле или в двух, где сразу можно и заполнить, и произвести действия, но не всегда так
    получится. Все от задачи. Порой сначала отдельно придется заполнить массив, потом выполнить какие-то операции, а потом уже выводить результат на экран.

    Также можно заполнить массив случайными числами с помощью ГСЧ. */

    // Заполнение массива случайными числами (ГСЧ):
    const int razmer = 20;
    int chisla[razmer]{};
    int count = 0;

    // Заполним массив случ.числами и объединим 3 этапа/цикла в один:
    for (int i = 0; i < razmer; i++)
    {
        // I - цикл
        chisla[i] = rand() % 100;
        // II - цикл
        if (chisla[i] % 2 == 0)count++;                                         // подсчитываем количество четных значений элементов (не порядковые номера массива!)
        // III - цикл
        cout << chisla[i] << " ";
    }
    cout << "\nКоличество четных элементов равно " << count << endl;

    /* Массив позволяет хранить в себе набор чисел (любых однотипных данных) и работать с ними неоднократно. Сгенерировав и показав свое содержание на экране, массив
    также продолжает хранить эти значения до тех пор пока мы их не изменим. Т.е. ниже можно сделать еще цикл вывода на экран только нечетных значений элементов. Также
    пройтись от начала и до конца только без ГСЧ, но с условием что если значения элементов нечетные (%2!=0), выведем их на экран. */

    for (int i = 0; i < razmer; i++)
    {
        if (chisla[i] % 2 != 0)cout << "Chisla[" << i << "]=" << chisla[i] << "; ";
    }
    cout << endl;                                                               // в цикле либо вне необходимо сделать перевод строки!

    /* Массив это ХРАНИЛИЩЕ, как переменная, но не для одной переменной, а для такого количества, которое мы создадим при создании массива. Они могут быть все заполнены
    значениями, а может часть быть не заполнена и стать нулями. Но их будет столько, сколько мы создали, след, размер массива нужно выбирать такой, чтобы он был подхо-
    дящим. */
}