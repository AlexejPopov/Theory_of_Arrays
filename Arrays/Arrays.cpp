#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;

/* Группировка данных - МАССИВЫ (хранилище, как и переменная, но не для 1-й переменной, а для нужного их количества). При необходимости объединить данные в одно целое
можно объединить ОДНОТИПНЫЕ данные в массив под общим именем. Массив - это набор однотипных данных, объединенных под одним именем. Массивы используются для обработки
большого количества ОДНОТИПНЫХ данных. Эти данные находятся в памяти друг за другом неразрывно, как вагоны поезда. Например, в массиве три объединенных элемента типа
int, их значения 3,1,4. Имя масива будет train. Каждый элемент массива, каждая переменная, каждое значение, которое в нем хранится называется элемент массива и обладает
одной характеристикой - индексом (порядковым номером в массиве). Нумерация элементов в массиве начинается с нуля. Каждый элемент массива имеет свой уникальный индекс
(индексы не повторяются). Т.о. в массивах есть правило: КОЛИЧЕСТВО ЭЛЕМЕНТОВ В МАССИВЕ РАВНО ИХ КОЛИЧЕСТВУ МИНУС ОДИН.

train состоит из 3-х int, и они могут вести себя как отдельные переменные, с которыми можно взаимодействовать как с отдельными переменными, но т.к. они вместе объедине-
ны одним именем, с этим именем тоже можно работать как с одним целым. Т.е. массив можно представлять как одно целое, состоящее из "n" элементов (в моем случае из 3-х),
а можно рассматривать как набор равнозначных равноценных элементов, где каждый элемент обладает своим собственным индексом. В моем случае размер массива 3, индексы 0,1,
2. Имя train, тип данных int (каждый элемент должен быть одного типа данных, например int).

                                                                              Как создается массив?
                                 Пишется тип данных, название массива, в квадратных скобках ставится индекс (количество элементов), а потом ';'
                                                                                  int Array[5];

Переменные в массиве можно не инициализировать. Это некорректно, но ошибки не будет. Без инициализации там везде будет мусор, оставшийся там от предыдущего владельца э-
той памяти. Чтобы работать с элементами массива (помещать в них значения, вывести их на экран, выполнить вычисления и прочее), надо с каждым элементом массива работать
индивидуально по его индексу. Чтобы обратиться к какому-то элементу массива лично, надо указать имя массива и в кв.скобках его индекс (применить операцию индексировани-
я). Выведу все 5 элементов массива на экран. Там везде мусор. Помещу туда значения, запишу Array[0] = -17; Но по-одному инициализировать переменные неудобно.

Если вывести на экран элемент массива, которого нет, например 15, то это сработает и выведется не мусор, а какое-то число. Т.к. с массивами работа ведется по их место-
положению в памяти, место под 15-й элемент будет высчитано в памяти. А число возникнет по след.логике: раз элементы лежат друг с другом неразрывно, 5 элементов типа int
займут в памяти 20 байт. А для 15-го элемента нужно отмотать 14 раз по 4 байта = 56 байт и потом там где-то в памяти найти 15-ю позицию. Та же картина будет если напишу
Array[-1], число будет высчитано для этого места. Для компилятора это не будет ошибка, он место вычислит, а для нас это будет ошибка (выход за границы массива).

(!) грубейшая ошибка будет при попытке ЗАПИСАТЬ что-то в то место, которое мне не приналежит (Array[15]=1000;) Значение вложится, и студия не посчитает это ошибкой т.к.
с массивами работа ведется по их местоположению в памяти. 1000 вложится в ячейку памяти, которая моей программе не принадлежит. При вводе int Array[5]; я прошу ОС выде-
лить 20 байт под хранение 5-ти элементов типа int, ОС выделяет. А получив 5 ячеек, я пытаюсь влезть в 15-ю и перезаписать ее. Одно дело если эта память принадлежит моей
программе, а если другой или же самой ОС (ОЗУ на всех одна). Полбеды просто вывести на экран (заглянуть туда), а перезаписывать нельзя! НА СКОЛЬКО ЭЛЕМЕНТОВ ЗАПРАШИВАЮ
ПАМЯТЬ, СО СТОЛЬКИМ КОЛИЧЕСТВОМ ЭЛЕМЕНТОВ И РАБОТАЮ, С ИНДЕКСАМИ ОТ НУЛЯ и до последнего элемента со значением N-1! */

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));

    // Создание массива из 5 целых чисел.
    int Array[5];                                                               // int (Array0, Array1, Array2, Array3, Array4)
    Array[0] = -17;                                                             // доступ к элементам массива по его индексу
    Array[1] = 3;
    Array[2] = -555;
    Array[3] = 12;
    Array[4] = 777;

    cout << Array[0] << endl;
    cout << Array[1] << endl;
    cout << Array[2] << endl;
    cout << Array[3] << endl;
    cout << Array[4] << endl;

    //cout << Array[15] << endl;
    //cout << Array[-1] << endl;
    system("pause");
    system("cls");

    /* Размер массива задается целочисленным литералом N в константе. Нельзя размер массива задать дробным числом (не может быть 3.5 элемента массива, как и 3.5 челове-
    ка), а также нельзя задавать переменными, т.к. переменная может измениться во время работы программы, а этого допускать нельзя. Если создать массив на 5 элементов,
    а потом изменить переменную на 50, словно в массиве 50 элементов, я попаду в чужую ячейку памяти.

    Неудобно заполнять массив, перечисляя все элементы. Поможет тут УИ (списковая/строковая инициализация). В ее фиг.скобках можно перечислить все значения элементов
    массива попорядку. Делать так ПОСЛЕ создания массива нельзя, только при создании массива. Создам новый массив int с именем А (массив также работает и с другими ти-
    пами данных). Теперь массив заполнен, выведу его на экран.
    Если я введу в свой массив из 4 элементов еще число 100 { -10,15,8,3,100 }, это будет ошибкой, программа не выполнится. Но если у меня массив из 4 элементов и я ту-
    да инициализирую лишь 3, то последний инициализируется нулем. Это абсолютно легитимно, след, можно инициализировать пустой массив, заполненный нулями. МЕНЬШЕ МОЖНО,
    БОЛЬШЕ НЕТ! */

    const int size = 4;
    int A[size] = { -10,15,8 };

    cout << A[0] << endl;
    cout << A[1] << endl;
    cout << A[2] << endl;
    cout << A[3] << endl;

    // Объявление и инициализация пустого массива, заполненного нулями.
    float B[size] = {};                                                         // с массивами знак '=' перед УИ можно не ставить float B[size]{};

    cout << "Массив В: " << endl;                                               // УИ помещает корректные значения. Если float, то литерал будет типа float и т.д.
    cout << B[0] << endl;
    cout << B[1] << endl;
    cout << B[2] << endl;
    cout << B[3] << endl;

    // Можно записать массив и горизонтально:
    double X[size] = { 0.3,4.4,3.5,5.6 };
    cout << "Массив X: " << endl;
    cout << X[0] << " " << X[1] << " " << X[2] << " " << X[3] << " " << endl;

    system("pause");
    /* Но неудобно их так один за другим выводить на экран, к каждому элементу нужно обращаться персонально. Т.к. выводы элементов массива на экран носят одинаковые
    действия, их можно поместить в цикл, особенно зная количество элементов в массиве. Добавим его в параметры цикла.

                                                                   Работа с элементами массива в цикле:
    (!) теперь ясно почему счетчик в цикле лучше начинать с нуля и меньше заданного числа, идеально попадаю в описание элементов массива. А отсюда и вывод на экран по-
    лучается без всяких доп.действий, просто вывод счетчика на экран! А после цикла необходимо поставить перевод строки. Каждый шаг цикла ассимилирую с индексом моего
    массива и тем самым сперва вывожу значение Array[0], потом Array[1], Array[2], Array[3] и Array[4].
    (!) несмотря на работу в цикле, обращаюсь я к каждому элементу массива персонально, по индексу (i), делая это в цикле, а не отдельно как раньше. В массиве с каждым
    элементом необходимо работать индивидуально, но, если операции одни и теже, можно делать это в цикле. */

    for (int i = 0; i < 5; i++)
    {
        cout << Array[i] << endl;                                               // либо можно через пробелы в одну строку
    }
    cout << endl;

    system("pause");
    system("cls");

    /* Можно массивы друг с другом складывать, перемножать, но ПОЭЛЕМЕНТНО! Один элемент одного массива с другим элементом другого массива и т.д. Целиком массив на мас-
    сив мы умножить/поделить... не можем!

    Циклы работы с массивами делятся на 3 этапа/цикла. Если нам позволяет задача и логика работы программы, мы можем все это соединить в один цикл, но не всегда так по-
    лучается. Рассмотрим на примере массива В этапы работы с массивом.


                                                                I. Цикл заполнения элементов массива */
    for (int i = 0; i < size; i++)
    {
        cout << "Введите значение " << i + 1 << "-го элемента массива: "; cin >> B[i];
    }
    /* Т.к. у массива В размер задан константой, ввожу все элементы массива В вручную по очереди. Как только массив заполнен перехожу к след. этапу.

                                                          II. Цикл выполнения действий над элементами массива
    Умножу первые два элемента массива на 2. Для этого элементы с индексами от 0 до 2 умножу на 2. Технически это будет так: i < size/2. Так можно делать в цикле. */

    for (int i = 0; i < size / 2; i++)                                          // элементы с индексами от 0 до 2 (size/2)
    {
        B[i] *= 2;                                                              // первую половину массива домножу на 2
    }
    /* Т.к. условие 2-го цикла отличается, видно, что в цикле обрабатывается не весь массив, след, нельзя скомбинировать циклы (либо нужно писать условие внутри цикла).
    Если бы условия моих циклов были бы абсолютно одинаковые, действия над элементами можно было бы выполнить в цикле заполнения.

                                                               III. Цикл вывода на экран элементов массива
    Выведу на экран все элементы массива. В 1-м цикле у меня одно условие, во 2-м другое, а в третьем 3-и параметры. */

    for (int i = 0; i < size; i++)
    {
        cout << "B[" << i << "]=" << B[i] << "; " << endl;
    }
    system("pause");
    system("cls");

    /* В большинстве случаев все пишется в 1-м цикле или в 2-х где сразу можно и заполнить, и произвести действия, но не всегда так получится. Все зависит от задачи.
    Порой сначала отдельно придется заполнить массив, потом выполнить какие-то операции, а потом уже выводить результат на экран.

    Выполню след.задачу, объединив 3 цикла в один: заполню массив с помощью ГСЧ, подсчитаю количество четных значений массива, выведу массив на экран и отдельно выведу
    на экран количество четных элементов массива. */

    const int razmer = 20;
    int chisla[razmer]{};
    int count = 0;

    for (int i = 0; i < razmer; i++)
    {
        chisla[i] = rand() % 100;
        if (chisla[i] % 2 == 0)count++;                                         // подсчет четных значений элементов (не порядковые номера массива!)
        cout << chisla[i] << " ";
    }
    cout << "\nКоличество четных элементов равно " << count << endl << endl;

    /* Массив позволяет хранить в себе набор чисел (любых однотипных данных) и работать с ними многократно. Сгенерировав и показав свое содержание на экране, массив
    также продолжает хранить эти значения до тех пор пока я их не изменю. Т.о. ниже можно сделать еще цикл вывода на экран только нечетных значений элементов: */

    for (int i = 0; i < razmer; i++)
    {
        if (chisla[i] % 2 != 0)cout << "Chisla[" << i << "]=" << chisla[i] << "; ";
        if (i == 19)cout << endl;
    }
    cout << endl;                                                               // в цикле либо вне необходимо сделать перевод строки!
}
/* Массив это ХРАНИЛИЩЕ, но не для одной переменной, а для такого количества, которого я создам при создании массива. Они могут быть все заполнены значениями, а может
часть быть не заполнена и стать нулями. Но их будет столько, сколько создам я, след, размер массива нужно выбирать такой, чтобы он был подходящим. */